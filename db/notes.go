// ZSFNOTE table
// ZSFNOTE ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZARCHIVED INTEGER, ZENCRYPTED INTEGER,
// 	ZHASFILES INTEGER, ZHASIMAGES INTEGER, ZHASSOURCECODE INTEGER, ZLOCKED INTEGER, ZORDER INTEGER,
// 	ZPERMANENTLYDELETED INTEGER, ZPINNED INTEGER, ZSHOWNINTODAYWIDGET INTEGER, ZSKIPSYNC INTEGER,
// 	 ZTODOCOMPLETED INTEGER, ZTODOINCOMPLETED INTEGER, ZTRASHED INTEGER, ZFOLDER INTEGER, ZPASSWORD INTEGER,
// 	 ZSERVERDATA INTEGER, ZARCHIVEDDATE TIMESTAMP, ZCONFLICTUNIQUEIDENTIFIERDATE TIMESTAMP, ZCREATIONDATE TIMESTAMP,
// 	 ZLOCKEDDATE TIMESTAMP, ZMODIFICATIONDATE TIMESTAMP, ZORDERDATE TIMESTAMP, ZPINNEDDATE TIMESTAMP, ZTRASHEDDATE TIMESTAMP,
// 		ZCONFLICTUNIQUEIDENTIFIER VARCHAR, ZENCRYPTIONUNIQUEIDENTIFIER VARCHAR, ZLASTEDITINGDEVICE VARCHAR, ZSUBTITLE VARCHAR,
// 		ZTEXT VARCHAR, ZTITLE VARCHAR, ZUNIQUEIDENTIFIER VARCHAR, ZENCRYPTEDDATA BLOB, ZVECTORCLOCK BLOB );

package db

import (
	"log"

	"github.com/jmoiron/sqlx"
	_ "github.com/mattn/go-sqlite3" // For SQL driver to be imported
)

// Note struct describes Bear Note table
type Note struct {
	ID           int     `db:"Z_PK"`
	CreationDate float64 `db:"ZCREATIONDATE"`
	UpdateDate   float64 `db:"ZMODIFICATIONDATE"`
	Body         string  `db:"ZTEXT"`
	Subtitle     string  `db:"ZSUBTITLE"`
	Title        string  `db:"ZTITLE"`
}

// ReadNotes reads bear note into Note struct
func ReadNotes(dbPath string) []Note {
	db, err := sqlx.Connect("sqlite3", dbPath)
	if err != nil {
		log.Fatalln(err)
	}
	var notes = []Note{}
	err = db.Select(&notes, "SELECT Z_PK, ZCREATIONDATE, ZMODIFICATIONDATE, ZTEXT, ZSUBTITLE, ZTITLE FROM ZSFNOTE")
	if err != nil {
		panic(err)
	}
	return notes
}
